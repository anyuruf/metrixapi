scalar Point
scalar DateTime
scalar PointInput

type User @exclude {
  id: ID! @id
  firstName: String!
  lastName: String!
  email: String!
  password: String!
  memAnchor: ID
  role: String!
  comments: [Comment] @relationship(type: "WROTE", direction: OUT)
}

type AuthToken @exclude {
  token: String!
}

type Comment {
  id: ID! @id
  text: String!
  created: DateTime
  member: Member @relationship(type: "COMMENTED", direction: OUT)
  user: User @relationship(type: "WROTE", direction: IN)
}

type Clan {
 id: ID! @id
 cname: String
 tribe: String
 members: [Member] @relationship(type: "BELONGS", direction: IN)
}


type Member {
  id: ID! @id
  firstName: String!
  lastName: String!
  gender: String!
  clan: Clan @relationship(type: "BELONGS", direction: OUT)
  comments: [Comment] @relationship(type: "COMMENTED", direction: IN)
}

type Query {
  currentUser: User
      @cypher(
        statement: """
        MATCH (u:User {id: $auth.jwt.id})
        RETURN u
        """
      )
}

type Mutation {
  signUp(
    firstName: String!,
    lastName: String!,
    email: String!,
    role: String,
    password: String!,
    dadAnchor: ID
  ): AuthToken

  login(email: String!, password: String!): AuthToken

}
# type Business {
#   businessId: ID!
#   name: String!
#   address: String
#   city: String
#   state: String
#   location: Point
#   avgStars: Float
#     @cypher(
#       statement: "MATCH (this)<-[:REVIEWS]-(r:Review) RETURN coalesce(avg(r.stars),0.0)"
#     )
#   reviews: [Review] @relationship(type: "REVIEWS", direction: IN)
#   categories: [Category] @relationship(type: "IN_CATEGORY", direction: OUT)
# }
#
# type Review {
#   reviewId: ID!
#   stars: Float
#   text: String
#   date: DateTime
#   business: Business @relationship(type: "REVIEWS", direction: OUT)
#   user: User @relationship(type: "WROTE", direction: IN)
# }
#
# type Category {
#   name: ID!
#   businesses: [Business] @relationship(type: "IN_CATEGORY", direction: IN)
# }
#
# type RatingCount @exclude {
#   stars: Float!
#   count: Int!
# }
#
# type Mutation {
#   mergeBusinessCategory(categories: [String!]!, businessId: ID!): Business
#     @cypher(
#       statement: "MATCH (b:Business {businessId: $businessId}) UNWIND $categories AS cat MERGE (c:Category {name: cat}) MERGE (b)-[:IN_CATEGORY]->(c) RETURN b"
#     )
#   mergeUser(name: String!, userId: ID!): User
#     @cypher(
#       statement: """
#       MERGE (u:User {userId: $userId})
#       ON CREATE SET u.name = $name
#       RETURN u
#       """
#     )
#   mergeBusiness(
#     businessId: ID!
#     name: String!
#     address: String!
#     city: String!
#     state: String!
#     latitude: Float!
#     longitude: Float!
#   ): Business
#     @cypher(
#       statement: """
#       MERGE (b:Business {businessId: $businessId})
#       ON CREATE SET b.name = $name,
#                     b.address = $address,
#                     b.city = $city,
#                     b.state = $state,
#                     b.location = Point({latitude: $latitude, longitude: $longitude})
#       RETURN b
#       """
#     )
# }
#
# type Query {
#   userCount: Int! @cypher(statement: "MATCH (u:User) RETURN COUNT(u)")
#   ratingsCount: [RatingCount]
#     @cypher(
#       statement: "MATCH (r:Review) WITH r.stars AS stars, COUNT(*) AS count ORDER BY stars RETURN {stars: stars, count: count}"
#     )
# }
